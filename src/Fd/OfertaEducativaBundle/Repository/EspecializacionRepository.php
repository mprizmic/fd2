<?php

namespace Fd\OfertaEducativaBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Fd\EstablecimientoBundle\Entity\Respuesta;
use Fd\TablaBundle\Entity\TipoEspecializacion;
use Fd\OfertaEducativaBundle\Entity\OfertaEducativa;

/**
 * EspecializacionRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class EspecializacionRepository extends EntityRepository {

    public function actualizar($entity) {
        $respuesta = new Respuesta();
        try {
            $em = $this->_em;
            $em->persist($entity);
            $em->flush();
            $respuesta->setClaveNueva($entity->getId());

            $respuesta->setCodigo(1);
            $respuesta->setMensaje('Se guardó la especialización exitosamente');
        } catch (Exception $e) {
            $respuesta->setCodigo(2);
            $respuesta->setMensaje('No se pudo guardar la especialización. Verifique los datos y reintente');
        }

        return $respuesta;
    }

    /**
     * Desde una especializcaion se asignan y desasignan establecimientos en los que se imparte
     * 
     * @todo cambiar la logica y comparar la lista de establecimientos que se manda por post para procesar con la previa, así se procesan sólo las diferencias.
     * @todo hacer una tansacción
     * 
     * @param type $especializacion
     * @param type $establecimientos
     * @return type
     */
    public function asignarEstablecimientos($especializacion, $establecimientos) {
        /**
         * Para cada establecimiento, si esta seleccionado se debe crear el registro de la tabla unidad_oferta (en caso de no preexistir).
         * Si no está seleccionado, se debe borrar el registro de dicha tabla (en caso de preexistir)
         */
        //cantidad de establecimientos asignados
        $contador_suma = 0;
        $contador_resta = 0;

        $respuesta = new Respuesta();
        //oferta educativa
        $oferta_educativa = $especializacion->getOferta();

        //repositorio donde se crea la unidad_oferta
        $repo_uo = $this->_em->getRepository('EstablecimientoBundle:UnidadOferta');

        //para cada establecimiento informado con el flag se le crea la oferta
        $establecimientos = $establecimientos['establecimientos'];
        foreach ($establecimientos as $key => $value) {

            $establecimiento = $this->_em->getRepository('EstablecimientoBundle:Establecimiento')->find($establecimientos[$key]['id']);
            $unidad_educativa = $establecimiento->getTerciario();
            //se verifica si ya existe la unidad_oferta
            $x = $unidad_educativa->getId();
            $x = $oferta_educativa->getId();
            $unidad_oferta = $repo_uo->findOneBy(array('unidades' => $unidad_educativa->getId(), 'ofertas' => $oferta_educativa->getId()));

            if ($establecimientos[$key]['flag']) {
                //si está tildado, o ya existe o hay que darlo de alta
                if (!$unidad_oferta) {
                    //no existe y hay que crearla
                    $respuesta = $repo_uo->crear($unidad_educativa, $oferta_educativa);
                    if ($respuesta->getCodigo() == 1) {
                        $contador_suma = $contador_suma + 1;
                    }
                }
            } else {
                if ($unidad_oferta) {
                    //existe y hay que darlo de baja
                    $respuesta = $repo_uo->eliminar($unidad_oferta);
                    if ($respuesta->getCodigo() == 1) {
                        $contador_resta = $contador_resta + 1;
                    }
                };
            }
        }

        if ($contador_suma > 1 or $contador_resta > 1) {
            $respuesta->setCodigo(1);
            $respuesta->getMensaje('Se asignaron ' . $contador_suma . ' establecimiento(s) y se desasignaron ' . $contador_resta . ' establecimiento(s)');
        } else {
            $respuesta->setCodigo(2);
            $respuesta->getMensaje('No se asignaron/desasignaron establecimientos. Verifique los datos y reintente.');
        };

        return $respuesta;
    }

    /**
     * crear una especializcaion implica crear el regitro de ofertaeducativa correspondiente
     * @param type $entity
     * @return \Fd\EstablecimientoBundle\Entity\Respuesta
     */
    public function crear($entity) {

        $em = $this->_em;

        $respuesta = new Respuesta();

        try {
            //busco entidad NIVEL
            //devuelve un array de una posicion
            $nivel = $em->getRepository('TablaBundle:Nivel')->findByAbreviatura('Ter');

            //se genera la oferta educativa
            $oferta = new OfertaEducativa();
            $oferta->setNivel($nivel[0]);
            $em->persist($oferta);

            //se genera la carrera
            $entity->setOferta($oferta);
            $em->persist($entity);
            $em->flush();

            $respuesta->setClaveNueva($entity->getId());

            $respuesta->setCodigo(1);
            $respuesta->setMensaje('Se guardó la especialización exitosamente');
        } catch (Exception $e) {
            $respuesta->setCodigo(2);
            $respuesta->setMensaje('No se pudo guardar la nueva especialización. Verifique los datos y reintente');
        }

        return $respuesta;
    }

    public function eliminar($id) {
        $respuesta = new Respuesta();

        $especializacion = $this->find($id);

        if (!$especializacion) {
            $respuesta->setCodigo(2);
            $respuesta->setMensaje('No se encontró el código que se desea eliminar');
        } else {
            try {
                $em = $this->_em;
                //capturo la oferta que hay que eliminar. Estoy borrando desde el lado propietario de la relacion
                $oferta = $especializacion->getOferta();
                //elimino la oferta
                //el registro de oferta_norma se elimina sola
                $em->remove($oferta);
                //elimino la carrera
                $em->remove($especializacion);
                $em->flush();

                $respuesta->setCodigo(1);
                $respuesta->setMensaje('La especialización fue eliminada exitosamente');
            } catch (\Exception $e) {
                $respuesta->setCodigo(3);
                $respuesta->setMensaje('No se pudo eliminar la especialización. Verifique los datos y reintente');
            }
        }
        return $respuesta;
    }

    /**
     * dado un establecimeinto devuelve las especializaciones del mismo
     */
    public function findEspecializacionesPorEstablecimiento($establecimiento) {
        $dql = "select esp
            from OfertaEducativaBundle:Especializacion esp 
            join esp.oferta o 
            join o.unidades u 
            join u.unidades ue
            join ue.establecimiento e 
            where e.id = :establecimiento";
        $q = $this->_em->createQuery($dql);
        $q->setParameter('establecimiento', $establecimiento);
        return $q->getResult();
    }

    public function qyAllOrdenado($campo) {
        return $this->createQueryBuilder('e')
                        ->orderBy('e.' . $campo)
                        ->getQuery();
    }

    /**
     * Devuelve la lista de especializaciones con el año de la ultima cohorte valida, ordenado descendente
     */
    public function findVencimiento($condicion = 'is not null') {
        $campo = 'e.ultima_cohorte_valida';
        $qb = $this->createQueryBuilder('e');
        $resultado = $qb
                        ->select( $campo, 'e.nombre', 'e.id')
                        ->innerJoin('TablaBundle:EstadoCarrera', 'ec')
                        ->where($campo . ' ' . $condicion)
                        ->andWhere('ec.codigo = :estado')
                        ->orderBy( $campo, 'DESC')
                        ->setParameter('estado', 'ACT')
                        ->getQuery()
                        ->getResult()
        ;
        return $resultado;
    }
    /**
     * Devuelve la lista de especializaciones sin datos en la ultima cohorte valida 
     */
    public function findSinVencimiento($condicion = 'is null'){
        return $this->findVencimiento($condicion);
    }

}